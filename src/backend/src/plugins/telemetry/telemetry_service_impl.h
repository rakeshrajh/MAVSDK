// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/master/protos/telemetry/telemetry.proto)

#include "telemetry/telemetry.grpc.pb.h"
#include "plugins/telemetry/telemetry.h"

#include "log.h"
#include <atomic>
#include <future>
#include <memory>
#include <vector>

namespace mavsdk {
namespace backend {

template<typename Telemetry = Telemetry>
class TelemetryServiceImpl final : public rpc::telemetry::TelemetryService::Service {
public:
    TelemetryServiceImpl(Telemetry& telemetry) : _telemetry(telemetry) {}

    template<typename ResponseType>
    void fillResponseWithResult(ResponseType* response, mavsdk::Telemetry::Result& result) const
    {
        auto rpc_result = translateToRpcResult(result);

        auto* rpc_telemetry_result = new rpc::telemetry::TelemetryResult();
        rpc_telemetry_result->set_result(rpc_result);
        rpc_telemetry_result->set_result_str(mavsdk::Telemetry::result_str(result));

        response->set_allocated_telemetry_result(rpc_telemetry_result);
    }

    static rpc::telemetry::FixType translateToRpcFixType(const mavsdk::Telemetry::FixType& fixType)
    {
        switch (fixType) {
            default:
                LogErr() << "Unknown fixType enum value: " << static_cast<int>(fixType);
            // FALLTHROUGH
            case mavsdk::Telemetry::FixType::NoGps:
                return rpc::telemetry::FIX_TYPE_NO_GPS;
            case mavsdk::Telemetry::FixType::NoFix:
                return rpc::telemetry::FIX_TYPE_NO_FIX;
            case mavsdk::Telemetry::FixType::Fix2D:
                return rpc::telemetry::FIX_TYPE_FIX_2D;
            case mavsdk::Telemetry::FixType::Fix3D:
                return rpc::telemetry::FIX_TYPE_FIX_3D;
            case mavsdk::Telemetry::FixType::FixDgps:
                return rpc::telemetry::FIX_TYPE_FIX_DGPS;
            case mavsdk::Telemetry::FixType::RtkFloat:
                return rpc::telemetry::FIX_TYPE_RTK_FLOAT;
            case mavsdk::Telemetry::FixType::RtkFixed:
                return rpc::telemetry::FIX_TYPE_RTK_FIXED;
        }
    }

    static rpc::telemetry::FlightMode
    translateToRpcFlightMode(const mavsdk::Telemetry::FlightMode& flightMode)
    {
        switch (flightMode) {
            default:
                LogErr() << "Unknown flightMode enum value: " << static_cast<int>(flightMode);
            // FALLTHROUGH
            case mavsdk::Telemetry::FlightMode::Unknown:
                return rpc::telemetry::FLIGHT_MODE_UNKNOWN;
            case mavsdk::Telemetry::FlightMode::Ready:
                return rpc::telemetry::FLIGHT_MODE_READY;
            case mavsdk::Telemetry::FlightMode::Takeoff:
                return rpc::telemetry::FLIGHT_MODE_TAKEOFF;
            case mavsdk::Telemetry::FlightMode::Hold:
                return rpc::telemetry::FLIGHT_MODE_HOLD;
            case mavsdk::Telemetry::FlightMode::Mission:
                return rpc::telemetry::FLIGHT_MODE_MISSION;
            case mavsdk::Telemetry::FlightMode::ReturnToLaunch:
                return rpc::telemetry::FLIGHT_MODE_RETURN_TO_LAUNCH;
            case mavsdk::Telemetry::FlightMode::Land:
                return rpc::telemetry::FLIGHT_MODE_LAND;
            case mavsdk::Telemetry::FlightMode::Offboard:
                return rpc::telemetry::FLIGHT_MODE_OFFBOARD;
            case mavsdk::Telemetry::FlightMode::FollowMe:
                return rpc::telemetry::FLIGHT_MODE_FOLLOW_ME;
            case mavsdk::Telemetry::FlightMode::Manual:
                return rpc::telemetry::FLIGHT_MODE_MANUAL;
            case mavsdk::Telemetry::FlightMode::Altctl:
                return rpc::telemetry::FLIGHT_MODE_ALTCTL;
            case mavsdk::Telemetry::FlightMode::Posctl:
                return rpc::telemetry::FLIGHT_MODE_POSCTL;
            case mavsdk::Telemetry::FlightMode::Acro:
                return rpc::telemetry::FLIGHT_MODE_ACRO;
            case mavsdk::Telemetry::FlightMode::Stabilized:
                return rpc::telemetry::FLIGHT_MODE_STABILIZED;
            case mavsdk::Telemetry::FlightMode::Rattitude:
                return rpc::telemetry::FLIGHT_MODE_RATTITUDE;
        }
    }

    static rpc::telemetry::StatusTextType
    translateToRpcStatusTextType(const mavsdk::Telemetry::StatusTextType& statusTextType)
    {
        switch (statusTextType) {
            default:
                LogErr() << "Unknown statusTextType enum value: "
                         << static_cast<int>(statusTextType);
            // FALLTHROUGH
            case mavsdk::Telemetry::StatusTextType::Info:
                return rpc::telemetry::STATUS_TEXT_TYPE_INFO;
            case mavsdk::Telemetry::StatusTextType::Warning:
                return rpc::telemetry::STATUS_TEXT_TYPE_WARNING;
            case mavsdk::Telemetry::StatusTextType::Critical:
                return rpc::telemetry::STATUS_TEXT_TYPE_CRITICAL;
        }
    }

    static rpc::telemetry::LandedState
    translateToRpcLandedState(const mavsdk::Telemetry::LandedState& landedState)
    {
        switch (landedState) {
            default:
                LogErr() << "Unknown landedState enum value: " << static_cast<int>(landedState);
            // FALLTHROUGH
            case mavsdk::Telemetry::LandedState::Unknown:
                return rpc::telemetry::LANDED_STATE_UNKNOWN;
            case mavsdk::Telemetry::LandedState::OnGround:
                return rpc::telemetry::LANDED_STATE_ON_GROUND;
            case mavsdk::Telemetry::LandedState::InAir:
                return rpc::telemetry::LANDED_STATE_IN_AIR;
            case mavsdk::Telemetry::LandedState::TakingOff:
                return rpc::telemetry::LANDED_STATE_TAKING_OFF;
            case mavsdk::Telemetry::LandedState::Landing:
                return rpc::telemetry::LANDED_STATE_LANDING;
        }
    }

    static std::unique_ptr<rpc::telemetry::Position>
    translateToRpcPosition(const mavsdk::Telemetry::Position& position)
    {
        std::unique_ptr<rpc::telemetry::Position> rpc_obj(new rpc::telemetry::Position());

        rpc_obj->set_latitude_deg(position.latitude_deg);

        rpc_obj->set_longitude_deg(position.longitude_deg);

        rpc_obj->set_absolute_altitude_m(position.absolute_altitude_m);

        rpc_obj->set_relative_altitude_m(position.relative_altitude_m);

        return rpc_obj;
    }

    static mavsdk::Telemetry::Position
    translateFromRpcPosition(const rpc::telemetry::Position& position)
    {
        mavsdk::Telemetry::Position obj;

        obj.latitude_deg = position.latitude_deg();
        obj.longitude_deg = position.longitude_deg();
        obj.absolute_altitude_m = position.absolute_altitude_m();
        obj.relative_altitude_m = position.relative_altitude_m();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::Quaternion>
    translateToRpcQuaternion(const mavsdk::Telemetry::Quaternion& quaternion)
    {
        std::unique_ptr<rpc::telemetry::Quaternion> rpc_obj(new rpc::telemetry::Quaternion());

        rpc_obj->set_w(quaternion.w);

        rpc_obj->set_x(quaternion.x);

        rpc_obj->set_y(quaternion.y);

        rpc_obj->set_z(quaternion.z);

        return rpc_obj;
    }

    static mavsdk::Telemetry::Quaternion
    translateFromRpcQuaternion(const rpc::telemetry::Quaternion& quaternion)
    {
        mavsdk::Telemetry::Quaternion obj;

        obj.w = quaternion.w();
        obj.x = quaternion.x();
        obj.y = quaternion.y();
        obj.z = quaternion.z();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::EulerAngle>
    translateToRpcEulerAngle(const mavsdk::Telemetry::EulerAngle& euler_angle)
    {
        std::unique_ptr<rpc::telemetry::EulerAngle> rpc_obj(new rpc::telemetry::EulerAngle());

        rpc_obj->set_roll_deg(euler_angle.roll_deg);

        rpc_obj->set_pitch_deg(euler_angle.pitch_deg);

        rpc_obj->set_yaw_deg(euler_angle.yaw_deg);

        return rpc_obj;
    }

    static mavsdk::Telemetry::EulerAngle
    translateFromRpcEulerAngle(const rpc::telemetry::EulerAngle& euler_angle)
    {
        mavsdk::Telemetry::EulerAngle obj;

        obj.roll_deg = euler_angle.roll_deg();
        obj.pitch_deg = euler_angle.pitch_deg();
        obj.yaw_deg = euler_angle.yaw_deg();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::AngularVelocityBody> translateToRpcAngularVelocityBody(
        const mavsdk::Telemetry::AngularVelocityBody& angular_velocity_body)
    {
        std::unique_ptr<rpc::telemetry::AngularVelocityBody> rpc_obj(
            new rpc::telemetry::AngularVelocityBody());

        rpc_obj->set_roll_rad_s(angular_velocity_body.roll_rad_s);

        rpc_obj->set_pitch_rad_s(angular_velocity_body.pitch_rad_s);

        rpc_obj->set_yaw_rad_s(angular_velocity_body.yaw_rad_s);

        return rpc_obj;
    }

    static mavsdk::Telemetry::AngularVelocityBody translateFromRpcAngularVelocityBody(
        const rpc::telemetry::AngularVelocityBody& angular_velocity_body)
    {
        mavsdk::Telemetry::AngularVelocityBody obj;

        obj.roll_rad_s = angular_velocity_body.roll_rad_s();
        obj.pitch_rad_s = angular_velocity_body.pitch_rad_s();
        obj.yaw_rad_s = angular_velocity_body.yaw_rad_s();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::SpeedNed>
    translateToRpcSpeedNed(const mavsdk::Telemetry::SpeedNed& speed_ned)
    {
        std::unique_ptr<rpc::telemetry::SpeedNed> rpc_obj(new rpc::telemetry::SpeedNed());

        rpc_obj->set_velocity_north_m_s(speed_ned.velocity_north_m_s);

        rpc_obj->set_velocity_east_m_s(speed_ned.velocity_east_m_s);

        rpc_obj->set_velocity_down_m_s(speed_ned.velocity_down_m_s);

        return rpc_obj;
    }

    static mavsdk::Telemetry::SpeedNed
    translateFromRpcSpeedNed(const rpc::telemetry::SpeedNed& speed_ned)
    {
        mavsdk::Telemetry::SpeedNed obj;

        obj.velocity_north_m_s = speed_ned.velocity_north_m_s();
        obj.velocity_east_m_s = speed_ned.velocity_east_m_s();
        obj.velocity_down_m_s = speed_ned.velocity_down_m_s();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::GpsInfo>
    translateToRpcGpsInfo(const mavsdk::Telemetry::GpsInfo& gps_info)
    {
        std::unique_ptr<rpc::telemetry::GpsInfo> rpc_obj(new rpc::telemetry::GpsInfo());

        rpc_obj->set_num_satellites(gps_info.num_satellites);

        rpc_obj->set_fix_type(translateToRpcFixType(gps_info.fix_type));

        return rpc_obj;
    }

    static mavsdk::Telemetry::GpsInfo
    translateFromRpcGpsInfo(const rpc::telemetry::GpsInfo& gps_info)
    {
        mavsdk::Telemetry::GpsInfo obj;

        obj.num_satellites = gps_info.num_satellites();
        obj.fix_type = gps_info.fix_type();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::Battery>
    translateToRpcBattery(const mavsdk::Telemetry::Battery& battery)
    {
        std::unique_ptr<rpc::telemetry::Battery> rpc_obj(new rpc::telemetry::Battery());

        rpc_obj->set_voltage_v(battery.voltage_v);

        rpc_obj->set_remaining_percent(battery.remaining_percent);

        return rpc_obj;
    }

    static mavsdk::Telemetry::Battery
    translateFromRpcBattery(const rpc::telemetry::Battery& battery)
    {
        mavsdk::Telemetry::Battery obj;

        obj.voltage_v = battery.voltage_v();
        obj.remaining_percent = battery.remaining_percent();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::Health>
    translateToRpcHealth(const mavsdk::Telemetry::Health& health)
    {
        std::unique_ptr<rpc::telemetry::Health> rpc_obj(new rpc::telemetry::Health());

        rpc_obj->set_is_gyrometer_calibration_ok(health.is_gyrometer_calibration_ok);

        rpc_obj->set_is_accelerometer_calibration_ok(health.is_accelerometer_calibration_ok);

        rpc_obj->set_is_magnetometer_calibration_ok(health.is_magnetometer_calibration_ok);

        rpc_obj->set_is_level_calibration_ok(health.is_level_calibration_ok);

        rpc_obj->set_is_local_position_ok(health.is_local_position_ok);

        rpc_obj->set_is_global_position_ok(health.is_global_position_ok);

        rpc_obj->set_is_home_position_ok(health.is_home_position_ok);

        return rpc_obj;
    }

    static mavsdk::Telemetry::Health translateFromRpcHealth(const rpc::telemetry::Health& health)
    {
        mavsdk::Telemetry::Health obj;

        obj.is_gyrometer_calibration_ok = health.is_gyrometer_calibration_ok();
        obj.is_accelerometer_calibration_ok = health.is_accelerometer_calibration_ok();
        obj.is_magnetometer_calibration_ok = health.is_magnetometer_calibration_ok();
        obj.is_level_calibration_ok = health.is_level_calibration_ok();
        obj.is_local_position_ok = health.is_local_position_ok();
        obj.is_global_position_ok = health.is_global_position_ok();
        obj.is_home_position_ok = health.is_home_position_ok();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::RcStatus>
    translateToRpcRcStatus(const mavsdk::Telemetry::RcStatus& rc_status)
    {
        std::unique_ptr<rpc::telemetry::RcStatus> rpc_obj(new rpc::telemetry::RcStatus());

        rpc_obj->set_was_available_once(rc_status.was_available_once);

        rpc_obj->set_is_available(rc_status.is_available);

        rpc_obj->set_signal_strength_percent(rc_status.signal_strength_percent);

        return rpc_obj;
    }

    static mavsdk::Telemetry::RcStatus
    translateFromRpcRcStatus(const rpc::telemetry::RcStatus& rc_status)
    {
        mavsdk::Telemetry::RcStatus obj;

        obj.was_available_once = rc_status.was_available_once();
        obj.is_available = rc_status.is_available();
        obj.signal_strength_percent = rc_status.signal_strength_percent();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::StatusText>
    translateToRpcStatusText(const mavsdk::Telemetry::StatusText& status_text)
    {
        std::unique_ptr<rpc::telemetry::StatusText> rpc_obj(new rpc::telemetry::StatusText());

        rpc_obj->set_type(translateToRpcStatusTextType(status_text.type));

        rpc_obj->set_text(status_text.text);

        return rpc_obj;
    }

    static mavsdk::Telemetry::StatusText
    translateFromRpcStatusText(const rpc::telemetry::StatusText& status_text)
    {
        mavsdk::Telemetry::StatusText obj;

        obj.type = status_text.type();
        obj.text = status_text.text();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::ActuatorControlTarget>
    translateToRpcActuatorControlTarget(
        const mavsdk::Telemetry::ActuatorControlTarget& actuator_control_target)
    {
        std::unique_ptr<rpc::telemetry::ActuatorControlTarget> rpc_obj(
            new rpc::telemetry::ActuatorControlTarget());

        rpc_obj->set_group(actuator_control_target.group);

        for (const auto& elem : actuator_control_target.controls) {
            rpc_obj->add_controls(elem);
        }

        return rpc_obj;
    }

    static mavsdk::Telemetry::ActuatorControlTarget translateFromRpcActuatorControlTarget(
        const rpc::telemetry::ActuatorControlTarget& actuator_control_target)
    {
        mavsdk::Telemetry::ActuatorControlTarget obj;

        obj.group = actuator_control_target.group();
        obj.controls = actuator_control_target.controls();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::ActuatorOutputStatus> translateToRpcActuatorOutputStatus(
        const mavsdk::Telemetry::ActuatorOutputStatus& actuator_output_status)
    {
        std::unique_ptr<rpc::telemetry::ActuatorOutputStatus> rpc_obj(
            new rpc::telemetry::ActuatorOutputStatus());

        rpc_obj->set_active(actuator_output_status.active);

        for (const auto& elem : actuator_output_status.actuator) {
            rpc_obj->add_actuator(elem);
        }

        return rpc_obj;
    }

    static mavsdk::Telemetry::ActuatorOutputStatus translateFromRpcActuatorOutputStatus(
        const rpc::telemetry::ActuatorOutputStatus& actuator_output_status)
    {
        mavsdk::Telemetry::ActuatorOutputStatus obj;

        obj.active = actuator_output_status.active();
        obj.actuator = actuator_output_status.actuator();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::Covariance>
    translateToRpcCovariance(const mavsdk::Telemetry::Covariance& covariance)
    {
        std::unique_ptr<rpc::telemetry::Covariance> rpc_obj(new rpc::telemetry::Covariance());

        for (const auto& elem : covariance.covariance_matrix) {
            rpc_obj->add_covariance_matrix(elem);
        }

        return rpc_obj;
    }

    static mavsdk::Telemetry::Covariance
    translateFromRpcCovariance(const rpc::telemetry::Covariance& covariance)
    {
        mavsdk::Telemetry::Covariance obj;

        obj.covariance_matrix = covariance.covariance_matrix();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::VelocityBody>
    translateToRpcVelocityBody(const mavsdk::Telemetry::VelocityBody& velocity_body)
    {
        std::unique_ptr<rpc::telemetry::VelocityBody> rpc_obj(new rpc::telemetry::VelocityBody());

        rpc_obj->set_x_m_s(velocity_body.x_m_s);

        rpc_obj->set_y_m_s(velocity_body.y_m_s);

        rpc_obj->set_z_m_s(velocity_body.z_m_s);

        return rpc_obj;
    }

    static mavsdk::Telemetry::VelocityBody
    translateFromRpcVelocityBody(const rpc::telemetry::VelocityBody& velocity_body)
    {
        mavsdk::Telemetry::VelocityBody obj;

        obj.x_m_s = velocity_body.x_m_s();
        obj.y_m_s = velocity_body.y_m_s();
        obj.z_m_s = velocity_body.z_m_s();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::PositionBody>
    translateToRpcPositionBody(const mavsdk::Telemetry::PositionBody& position_body)
    {
        std::unique_ptr<rpc::telemetry::PositionBody> rpc_obj(new rpc::telemetry::PositionBody());

        rpc_obj->set_x_m(position_body.x_m);

        rpc_obj->set_y_m(position_body.y_m);

        rpc_obj->set_z_m(position_body.z_m);

        return rpc_obj;
    }

    static mavsdk::Telemetry::PositionBody
    translateFromRpcPositionBody(const rpc::telemetry::PositionBody& position_body)
    {
        mavsdk::Telemetry::PositionBody obj;

        obj.x_m = position_body.x_m();
        obj.y_m = position_body.y_m();
        obj.z_m = position_body.z_m();
        return obj;
    }

    static rpc::telemetry::Odometry::MavFrame
    translateToRpcMavFrame(const mavsdk::Telemetry::MavFrame& mavFrame)
    {
        switch (mavFrame) {
            default:
                LogErr() << "Unknown mavFrame enum value: " << static_cast<int>(mavFrame);
            // FALLTHROUGH
            case mavsdk::Telemetry::MavFrame::Undef:
                return rpc::telemetry::Odometry_MavFrame_MAV_FRAME_UNDEF;
            case mavsdk::Telemetry::MavFrame::BodyNed:
                return rpc::telemetry::Odometry_MavFrame_MAV_FRAME_BODY_NED;
            case mavsdk::Telemetry::MavFrame::VisionNed:
                return rpc::telemetry::Odometry_MavFrame_MAV_FRAME_VISION_NED;
            case mavsdk::Telemetry::MavFrame::EstimNed:
                return rpc::telemetry::Odometry_MavFrame_MAV_FRAME_ESTIM_NED;
        }
    }

    static std::unique_ptr<rpc::telemetry::Odometry>
    translateToRpcOdometry(const mavsdk::Telemetry::Odometry& odometry)
    {
        std::unique_ptr<rpc::telemetry::Odometry> rpc_obj(new rpc::telemetry::Odometry());

        rpc_obj->set_time_usec(odometry.time_usec);

        rpc_obj->set_frame_id(translateToRpcMavFrame(odometry.frame_id));

        rpc_obj->set_child_frame_id(translateToRpcMavFrame(odometry.child_frame_id));

        rpc_obj->set_allocated_position_body(
            translateToRpcPositionBody(odometry.position_body).release());

        rpc_obj->set_allocated_q(translateToRpcQuaternion(odometry.q).release());

        rpc_obj->set_allocated_velocity_body(
            translateToRpcVelocityBody(odometry.velocity_body).release());

        rpc_obj->set_allocated_angular_velocity_body(
            translateToRpcAngularVelocityBody(odometry.angular_velocity_body).release());

        rpc_obj->set_allocated_pose_covariance(
            translateToRpcCovariance(odometry.pose_covariance).release());

        rpc_obj->set_allocated_velocity_covariance(
            translateToRpcCovariance(odometry.velocity_covariance).release());

        return rpc_obj;
    }

    static mavsdk::Telemetry::Odometry
    translateFromRpcOdometry(const rpc::telemetry::Odometry& odometry)
    {
        mavsdk::Telemetry::Odometry obj;

        obj.time_usec = odometry.time_usec();
        obj.frame_id = odometry.frame_id();
        obj.child_frame_id = odometry.child_frame_id();
        obj.position_body = odometry.position_body();
        obj.q = odometry.q();
        obj.velocity_body = odometry.velocity_body();
        obj.angular_velocity_body = odometry.angular_velocity_body();
        obj.pose_covariance = odometry.pose_covariance();
        obj.velocity_covariance = odometry.velocity_covariance();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::PositionNed>
    translateToRpcPositionNed(const mavsdk::Telemetry::PositionNed& position_ned)
    {
        std::unique_ptr<rpc::telemetry::PositionNed> rpc_obj(new rpc::telemetry::PositionNed());

        rpc_obj->set_north_m(position_ned.north_m);

        rpc_obj->set_east_m(position_ned.east_m);

        rpc_obj->set_down_m(position_ned.down_m);

        return rpc_obj;
    }

    static mavsdk::Telemetry::PositionNed
    translateFromRpcPositionNed(const rpc::telemetry::PositionNed& position_ned)
    {
        mavsdk::Telemetry::PositionNed obj;

        obj.north_m = position_ned.north_m();
        obj.east_m = position_ned.east_m();
        obj.down_m = position_ned.down_m();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::VelocityNed>
    translateToRpcVelocityNed(const mavsdk::Telemetry::VelocityNed& velocity_ned)
    {
        std::unique_ptr<rpc::telemetry::VelocityNed> rpc_obj(new rpc::telemetry::VelocityNed());

        rpc_obj->set_north_m_s(velocity_ned.north_m_s);

        rpc_obj->set_east_m_s(velocity_ned.east_m_s);

        rpc_obj->set_down_m_s(velocity_ned.down_m_s);

        return rpc_obj;
    }

    static mavsdk::Telemetry::VelocityNed
    translateFromRpcVelocityNed(const rpc::telemetry::VelocityNed& velocity_ned)
    {
        mavsdk::Telemetry::VelocityNed obj;

        obj.north_m_s = velocity_ned.north_m_s();
        obj.east_m_s = velocity_ned.east_m_s();
        obj.down_m_s = velocity_ned.down_m_s();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::PositionVelocityNed> translateToRpcPositionVelocityNed(
        const mavsdk::Telemetry::PositionVelocityNed& position_velocity_ned)
    {
        std::unique_ptr<rpc::telemetry::PositionVelocityNed> rpc_obj(
            new rpc::telemetry::PositionVelocityNed());

        rpc_obj->set_allocated_position(
            translateToRpcPositionNed(position_velocity_ned.position).release());

        rpc_obj->set_allocated_velocity(
            translateToRpcVelocityNed(position_velocity_ned.velocity).release());

        return rpc_obj;
    }

    static mavsdk::Telemetry::PositionVelocityNed translateFromRpcPositionVelocityNed(
        const rpc::telemetry::PositionVelocityNed& position_velocity_ned)
    {
        mavsdk::Telemetry::PositionVelocityNed obj;

        obj.position = position_velocity_ned.position();
        obj.velocity = position_velocity_ned.velocity();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::GroundTruth>
    translateToRpcGroundTruth(const mavsdk::Telemetry::GroundTruth& ground_truth)
    {
        std::unique_ptr<rpc::telemetry::GroundTruth> rpc_obj(new rpc::telemetry::GroundTruth());

        rpc_obj->set_latitude_deg(ground_truth.latitude_deg);

        rpc_obj->set_longitude_deg(ground_truth.longitude_deg);

        rpc_obj->set_absolute_altitude_m(ground_truth.absolute_altitude_m);

        return rpc_obj;
    }

    static mavsdk::Telemetry::GroundTruth
    translateFromRpcGroundTruth(const rpc::telemetry::GroundTruth& ground_truth)
    {
        mavsdk::Telemetry::GroundTruth obj;

        obj.latitude_deg = ground_truth.latitude_deg();
        obj.longitude_deg = ground_truth.longitude_deg();
        obj.absolute_altitude_m = ground_truth.absolute_altitude_m();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::FixedwingMetrics>
    translateToRpcFixedwingMetrics(const mavsdk::Telemetry::FixedwingMetrics& fixedwing_metrics)
    {
        std::unique_ptr<rpc::telemetry::FixedwingMetrics> rpc_obj(
            new rpc::telemetry::FixedwingMetrics());

        rpc_obj->set_airspeed_m_s(fixedwing_metrics.airspeed_m_s);

        rpc_obj->set_throttle_percentage(fixedwing_metrics.throttle_percentage);

        rpc_obj->set_climb_rate_m_s(fixedwing_metrics.climb_rate_m_s);

        return rpc_obj;
    }

    static mavsdk::Telemetry::FixedwingMetrics
    translateFromRpcFixedwingMetrics(const rpc::telemetry::FixedwingMetrics& fixedwing_metrics)
    {
        mavsdk::Telemetry::FixedwingMetrics obj;

        obj.airspeed_m_s = fixedwing_metrics.airspeed_m_s();
        obj.throttle_percentage = fixedwing_metrics.throttle_percentage();
        obj.climb_rate_m_s = fixedwing_metrics.climb_rate_m_s();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::AccelerationFrd>
    translateToRpcAccelerationFrd(const mavsdk::Telemetry::AccelerationFrd& acceleration_frd)
    {
        std::unique_ptr<rpc::telemetry::AccelerationFrd> rpc_obj(
            new rpc::telemetry::AccelerationFrd());

        rpc_obj->set_forward_m_s2(acceleration_frd.forward_m_s2);

        rpc_obj->set_right_m_s2(acceleration_frd.right_m_s2);

        rpc_obj->set_down_m_s2(acceleration_frd.down_m_s2);

        return rpc_obj;
    }

    static mavsdk::Telemetry::AccelerationFrd
    translateFromRpcAccelerationFrd(const rpc::telemetry::AccelerationFrd& acceleration_frd)
    {
        mavsdk::Telemetry::AccelerationFrd obj;

        obj.forward_m_s2 = acceleration_frd.forward_m_s2();
        obj.right_m_s2 = acceleration_frd.right_m_s2();
        obj.down_m_s2 = acceleration_frd.down_m_s2();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::AngularVelocityFrd> translateToRpcAngularVelocityFrd(
        const mavsdk::Telemetry::AngularVelocityFrd& angular_velocity_frd)
    {
        std::unique_ptr<rpc::telemetry::AngularVelocityFrd> rpc_obj(
            new rpc::telemetry::AngularVelocityFrd());

        rpc_obj->set_forward_rad_s(angular_velocity_frd.forward_rad_s);

        rpc_obj->set_right_rad_s(angular_velocity_frd.right_rad_s);

        rpc_obj->set_down_rad_s(angular_velocity_frd.down_rad_s);

        return rpc_obj;
    }

    static mavsdk::Telemetry::AngularVelocityFrd translateFromRpcAngularVelocityFrd(
        const rpc::telemetry::AngularVelocityFrd& angular_velocity_frd)
    {
        mavsdk::Telemetry::AngularVelocityFrd obj;

        obj.forward_rad_s = angular_velocity_frd.forward_rad_s();
        obj.right_rad_s = angular_velocity_frd.right_rad_s();
        obj.down_rad_s = angular_velocity_frd.down_rad_s();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::MagneticFieldFrd>
    translateToRpcMagneticFieldFrd(const mavsdk::Telemetry::MagneticFieldFrd& magnetic_field_frd)
    {
        std::unique_ptr<rpc::telemetry::MagneticFieldFrd> rpc_obj(
            new rpc::telemetry::MagneticFieldFrd());

        rpc_obj->set_forward_gauss(magnetic_field_frd.forward_gauss);

        rpc_obj->set_right_gauss(magnetic_field_frd.right_gauss);

        rpc_obj->set_down_gauss(magnetic_field_frd.down_gauss);

        return rpc_obj;
    }

    static mavsdk::Telemetry::MagneticFieldFrd
    translateFromRpcMagneticFieldFrd(const rpc::telemetry::MagneticFieldFrd& magnetic_field_frd)
    {
        mavsdk::Telemetry::MagneticFieldFrd obj;

        obj.forward_gauss = magnetic_field_frd.forward_gauss();
        obj.right_gauss = magnetic_field_frd.right_gauss();
        obj.down_gauss = magnetic_field_frd.down_gauss();
        return obj;
    }

    static std::unique_ptr<rpc::telemetry::Imu> translateToRpcImu(const mavsdk::Telemetry::Imu& imu)
    {
        std::unique_ptr<rpc::telemetry::Imu> rpc_obj(new rpc::telemetry::Imu());

        rpc_obj->set_allocated_acceleration_frd(
            translateToRpcAccelerationFrd(imu.acceleration_frd).release());

        rpc_obj->set_allocated_angular_velocity_frd(
            translateToRpcAngularVelocityFrd(imu.angular_velocity_frd).release());

        rpc_obj->set_allocated_magnetic_field_frd(
            translateToRpcMagneticFieldFrd(imu.magnetic_field_frd).release());

        rpc_obj->set_temperature_degc(imu.temperature_degc);

        return rpc_obj;
    }

    static mavsdk::Telemetry::Imu translateFromRpcImu(const rpc::telemetry::Imu& imu)
    {
        mavsdk::Telemetry::Imu obj;

        obj.acceleration_frd = imu.acceleration_frd();
        obj.angular_velocity_frd = imu.angular_velocity_frd();
        obj.magnetic_field_frd = imu.magnetic_field_frd();
        obj.temperature_degc = imu.temperature_degc();
        return obj;
    }

    static rpc::telemetry::TelemetryResult::Result
    translateToRpcResult(const mavsdk::Telemetry::Result& result)
    {
        switch (result) {
            default:
                LogErr() << "Unknown result enum value: " << static_cast<int>(result);
            // FALLTHROUGH
            case mavsdk::Telemetry::Result::Unknown:
                return rpc::telemetry::TelemetryResult_Result_RESULT_UNKNOWN;
            case mavsdk::Telemetry::Result::Success:
                return rpc::telemetry::TelemetryResult_Result_RESULT_SUCCESS;
            case mavsdk::Telemetry::Result::NoSystem:
                return rpc::telemetry::TelemetryResult_Result_RESULT_NO_SYSTEM;
            case mavsdk::Telemetry::Result::ConnectionError:
                return rpc::telemetry::TelemetryResult_Result_RESULT_CONNECTION_ERROR;
            case mavsdk::Telemetry::Result::Busy:
                return rpc::telemetry::TelemetryResult_Result_RESULT_BUSY;
            case mavsdk::Telemetry::Result::CommandDenied:
                return rpc::telemetry::TelemetryResult_Result_RESULT_COMMAND_DENIED;
            case mavsdk::Telemetry::Result::Timeout:
                return rpc::telemetry::TelemetryResult_Result_RESULT_TIMEOUT;
        }
    }

    grpc::Status SubscribePosition(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribePositionRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::PositionResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.position_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::Position& position) {
                rpc::telemetry::PositionResponse rpc_response;

                rpc_response.set_allocated_position(translateToRpcPosition(position).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.position_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeHome(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeHomeRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::HomeResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.home_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::Position& home) {
                rpc::telemetry::HomeResponse rpc_response;

                rpc_response.set_allocated_home(translateToRpcPosition(home).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.home_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeInAir(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeInAirRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::InAirResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.in_air_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const bool& in_air) {
                rpc::telemetry::InAirResponse rpc_response;

                rpc_response.set_is_in_air(in_air);

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.in_air_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeLandedState(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeLandedStateRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::LandedStateResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.landed_state_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::LandedState& landed_state) {
                rpc::telemetry::LandedStateResponse rpc_response;

                rpc_response.set_landed_state(translateToRpcLandedState(landed_state));

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.landed_state_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeArmed(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeArmedRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::ArmedResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.armed_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const bool& armed) {
                rpc::telemetry::ArmedResponse rpc_response;

                rpc_response.set_is_armed(armed);

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.armed_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeAttitudeQuaternion(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeAttitudeQuaternionRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::AttitudeQuaternionResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.attitude_quaternion_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::Quaternion& attitude_quaternion) {
                rpc::telemetry::AttitudeQuaternionResponse rpc_response;

                rpc_response.set_allocated_attitude_quaternion(
                    translateToRpcQuaternion(attitude_quaternion).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.attitude_quaternion_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeAttitudeEuler(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeAttitudeEulerRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::AttitudeEulerResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.attitude_euler_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::EulerAngle& attitude_euler) {
                rpc::telemetry::AttitudeEulerResponse rpc_response;

                rpc_response.set_allocated_attitude_euler(
                    translateToRpcEulerAngle(attitude_euler).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.attitude_euler_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeAttitudeAngularVelocityBody(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeAttitudeAngularVelocityBodyRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::AttitudeAngularVelocityBodyResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.attitude_angular_velocity_body_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::AngularVelocityBody& attitude_angular_velocity_body) {
                rpc::telemetry::AttitudeAngularVelocityBodyResponse rpc_response;

                rpc_response.set_allocated_attitude_angular_velocity_body(
                    translateToRpcAngularVelocityBody(attitude_angular_velocity_body).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.attitude_angular_velocity_body_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeCameraAttitudeQuaternion(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeCameraAttitudeQuaternionRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::CameraAttitudeQuaternionResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.camera_attitude_quaternion_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::Quaternion& camera_attitude_quaternion) {
                rpc::telemetry::CameraAttitudeQuaternionResponse rpc_response;

                rpc_response.set_allocated_attitude_quaternion(
                    translateToRpcQuaternion(camera_attitude_quaternion).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.camera_attitude_quaternion_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeCameraAttitudeEuler(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeCameraAttitudeEulerRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::CameraAttitudeEulerResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.camera_attitude_euler_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::EulerAngle& camera_attitude_euler) {
                rpc::telemetry::CameraAttitudeEulerResponse rpc_response;

                rpc_response.set_allocated_attitude_euler(
                    translateToRpcEulerAngle(camera_attitude_euler).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.camera_attitude_euler_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeGroundSpeedNed(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeGroundSpeedNedRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::GroundSpeedNedResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.ground_speed_ned_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::SpeedNed& ground_speed_ned) {
                rpc::telemetry::GroundSpeedNedResponse rpc_response;

                rpc_response.set_allocated_ground_speed_ned(
                    translateToRpcSpeedNed(ground_speed_ned).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.ground_speed_ned_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeGpsInfo(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeGpsInfoRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::GpsInfoResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.gps_info_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::GpsInfo& gps_info) {
                rpc::telemetry::GpsInfoResponse rpc_response;

                rpc_response.set_allocated_gps_info(translateToRpcGpsInfo(gps_info).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.gps_info_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeBattery(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeBatteryRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::BatteryResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.battery_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::Battery& battery) {
                rpc::telemetry::BatteryResponse rpc_response;

                rpc_response.set_allocated_battery(translateToRpcBattery(battery).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.battery_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeFlightMode(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeFlightModeRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::FlightModeResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.flight_mode_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::FlightMode& flight_mode) {
                rpc::telemetry::FlightModeResponse rpc_response;

                rpc_response.set_flight_mode(translateToRpcFlightMode(flight_mode));

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.flight_mode_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeHealth(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeHealthRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::HealthResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.health_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::Health& health) {
                rpc::telemetry::HealthResponse rpc_response;

                rpc_response.set_allocated_health(translateToRpcHealth(health).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.health_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeRcStatus(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeRcStatusRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::RcStatusResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.rc_status_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::RcStatus& rc_status) {
                rpc::telemetry::RcStatusResponse rpc_response;

                rpc_response.set_allocated_rc_status(translateToRpcRcStatus(rc_status).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.rc_status_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeStatusText(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeStatusTextRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::StatusTextResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.status_text_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::StatusText& status_text) {
                rpc::telemetry::StatusTextResponse rpc_response;

                rpc_response.set_allocated_status_text(
                    translateToRpcStatusText(status_text).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.status_text_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeActuatorControlTarget(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeActuatorControlTargetRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::ActuatorControlTargetResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.actuator_control_target_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::ActuatorControlTarget& actuator_control_target) {
                rpc::telemetry::ActuatorControlTargetResponse rpc_response;

                rpc_response.set_allocated_actuator_control_target(
                    translateToRpcActuatorControlTarget(actuator_control_target).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.actuator_control_target_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeActuatorOutputStatus(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeActuatorOutputStatusRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::ActuatorOutputStatusResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.actuator_output_status_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::ActuatorOutputStatus& actuator_output_status) {
                rpc::telemetry::ActuatorOutputStatusResponse rpc_response;

                rpc_response.set_allocated_actuator_output_status(
                    translateToRpcActuatorOutputStatus(actuator_output_status).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.actuator_output_status_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeOdometry(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeOdometryRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::OdometryResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.odometry_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::Odometry& odometry) {
                rpc::telemetry::OdometryResponse rpc_response;

                rpc_response.set_allocated_odometry(translateToRpcOdometry(odometry).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.odometry_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribePositionVelocityNed(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribePositionVelocityNedRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::PositionVelocityNedResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.position_velocity_ned_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::PositionVelocityNed& position_velocity_ned) {
                rpc::telemetry::PositionVelocityNedResponse rpc_response;

                rpc_response.set_allocated_position_velocity_ned(
                    translateToRpcPositionVelocityNed(position_velocity_ned).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.position_velocity_ned_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeGroundTruth(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeGroundTruthRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::GroundTruthResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.ground_truth_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::GroundTruth& ground_truth) {
                rpc::telemetry::GroundTruthResponse rpc_response;

                rpc_response.set_allocated_ground_truth(
                    translateToRpcGroundTruth(ground_truth).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.ground_truth_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeFixedwingMetrics(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeFixedwingMetricsRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::FixedwingMetricsResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.fixedwing_metrics_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const mavsdk::Telemetry::FixedwingMetrics& fixedwing_metrics) {
                rpc::telemetry::FixedwingMetricsResponse rpc_response;

                rpc_response.set_allocated_fixedwing_metrics(
                    translateToRpcFixedwingMetrics(fixedwing_metrics).release());

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.fixedwing_metrics_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeImu(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeImuRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::ImuResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.imu_async([this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                                 const mavsdk::Telemetry::Imu& imu) {
            rpc::telemetry::ImuResponse rpc_response;

            rpc_response.set_allocated_imu(translateToRpcImu(imu).release());

            std::lock_guard<std::mutex> lock(subscribe_mutex);
            if (!*is_finished && !writer->Write(rpc_response)) {
                _telemetry.imu_async(nullptr);
                *is_finished = true;
                unregister_stream_stop_promise(stream_closed_promise);
                stream_closed_promise->set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeHealthAllOk(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeHealthAllOkRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::HealthAllOkResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.health_all_ok_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const bool& health_all_ok) {
                rpc::telemetry::HealthAllOkResponse rpc_response;

                rpc_response.set_is_health_all_ok(health_all_ok);

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.health_all_ok_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SubscribeUnixEpochTime(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::telemetry::SubscribeUnixEpochTimeRequest* /* request */,
        grpc::ServerWriter<rpc::telemetry::UnixEpochTimeResponse>* writer) override
    {
        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);

        std::mutex subscribe_mutex{};

        _telemetry.unix_epoch_time_async(
            [this, &writer, &stream_closed_promise, is_finished, &subscribe_mutex](
                const uint64_t& unix_epoch_time) {
                rpc::telemetry::UnixEpochTimeResponse rpc_response;

                rpc_response.set_time_us(unix_epoch_time);

                std::lock_guard<std::mutex> lock(subscribe_mutex);
                if (!*is_finished && !writer->Write(rpc_response)) {
                    _telemetry.unix_epoch_time_async(nullptr);
                    *is_finished = true;
                    unregister_stream_stop_promise(stream_closed_promise);
                    stream_closed_promise->set_value();
                }
            });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SetRatePosition(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRatePositionRequest* request,
        rpc::telemetry::SetRatePositionResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRatePosition sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_position(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateHome(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateHomeRequest* request,
        rpc::telemetry::SetRateHomeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateHome sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_home(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateInAir(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateInAirRequest* request,
        rpc::telemetry::SetRateInAirResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateInAir sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_in_air(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateLandedState(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateLandedStateRequest* request,
        rpc::telemetry::SetRateLandedStateResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateLandedState sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_landed_state(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateAttitude(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateAttitudeRequest* request,
        rpc::telemetry::SetRateAttitudeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateAttitude sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_attitude(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateCameraAttitude(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateCameraAttitudeRequest* request,
        rpc::telemetry::SetRateCameraAttitudeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateCameraAttitude sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_camera_attitude(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateGroundSpeedNed(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateGroundSpeedNedRequest* request,
        rpc::telemetry::SetRateGroundSpeedNedResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateGroundSpeedNed sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_ground_speed_ned(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateGpsInfo(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateGpsInfoRequest* request,
        rpc::telemetry::SetRateGpsInfoResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateGpsInfo sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_gps_info(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateBattery(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateBatteryRequest* request,
        rpc::telemetry::SetRateBatteryResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateBattery sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_battery(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateRcStatus(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateRcStatusRequest* request,
        rpc::telemetry::SetRateRcStatusResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateRcStatus sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_rc_status(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateActuatorControlTarget(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateActuatorControlTargetRequest* request,
        rpc::telemetry::SetRateActuatorControlTargetResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateActuatorControlTarget sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_actuator_control_target(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateActuatorOutputStatus(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateActuatorOutputStatusRequest* request,
        rpc::telemetry::SetRateActuatorOutputStatusResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateActuatorOutputStatus sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_actuator_output_status(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateOdometry(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateOdometryRequest* request,
        rpc::telemetry::SetRateOdometryResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateOdometry sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_odometry(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRatePositionVelocityNed(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRatePositionVelocityNedRequest* request,
        rpc::telemetry::SetRatePositionVelocityNedResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRatePositionVelocityNed sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_position_velocity_ned(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateGroundTruth(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateGroundTruthRequest* request,
        rpc::telemetry::SetRateGroundTruthResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateGroundTruth sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_ground_truth(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateFixedwingMetrics(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateFixedwingMetricsRequest* request,
        rpc::telemetry::SetRateFixedwingMetricsResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateFixedwingMetrics sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_fixedwing_metrics(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateImu(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateImuRequest* request,
        rpc::telemetry::SetRateImuResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateImu sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_imu(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateUnixEpochTime(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateUnixEpochTimeRequest* request,
        rpc::telemetry::SetRateUnixEpochTimeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateUnixEpochTime sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_unix_epoch_time(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    void stop()
    {
        _stopped.store(true);
        for (auto& prom : _stream_stop_promises) {
            if (auto handle = prom.lock()) {
                handle->set_value();
            }
        }
    }

private:
    void register_stream_stop_promise(std::weak_ptr<std::promise<void>> prom)
    {
        // If we have already stopped, set promise immediately and don't add it to list.
        if (_stopped.load()) {
            if (auto handle = prom.lock()) {
                handle->set_value();
            }
        } else {
            _stream_stop_promises.push_back(prom);
        }
    }

    void unregister_stream_stop_promise(std::shared_ptr<std::promise<void>> prom)
    {
        for (auto it = _stream_stop_promises.begin(); it != _stream_stop_promises.end();
             /* ++it */) {
            if (it->lock() == prom) {
                it = _stream_stop_promises.erase(it);
            } else {
                ++it;
            }
        }
    }

    Telemetry& _telemetry;
    std::atomic<bool> _stopped{false};
    std::vector<std::weak_ptr<std::promise<void>>> _stream_stop_promises{};
};

} // namespace backend
} // namespace mavsdk